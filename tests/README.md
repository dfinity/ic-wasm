To regenerate the Wasm file:

* `wat.wasm` is generated from the [dfinity/examples/wasm/counter](https://github.com/dfinity/examples/tree/master/wasm/counter)
* `motoko.wasm` is generated from [dfinity/examples/motoko/counter](https://github.com/dfinity/examples/tree/master/motoko/counter)
* `motoko-region.wasm` is generated by adding the following in the Motoko counter code:
```rust
actor {
  let region = Region.new();
  ignore Region.grow(region, 32);
  ...
```
* `rust.wasm` is generated from [dfinity/examples/rust/counter](https://github.com/dfinity/examples/tree/master/rust/counter), and add the following pre/post-upgrade hooks:
```rust
thread_local! {
    static MEMORY_MANAGER: RefCell<MemoryManager<DefaultMemoryImpl>> =
        RefCell::new(MemoryManager::init(DefaultMemoryImpl::default()));
}

const UPGRADES: MemoryId = MemoryId::new(0);

#[ic_cdk::pre_upgrade]
fn pre_upgrade() {
    let bytes = COUNTER.with(|counter| Encode!(counter).unwrap());
    let len = bytes.len() as u32;
    let mut memory = MEMORY_MANAGER.with(|m| m.borrow().get(UPGRADES));
    let mut writer = Writer::new(&mut memory, 0);
    writer.write(&len.to_le_bytes()).unwrap();
    writer.write(&bytes).unwrap();
}
#[ic_cdk::post_upgrade]
fn post_upgrade() {
    let memory = MEMORY_MANAGER.with(|m| m.borrow().get(UPGRADES));
    let mut len_bytes = [0; 4];
    memory.read(0, &mut len_bytes);
    let len = u32::from_le_bytes(len_bytes) as usize;
    let mut bytes = vec![0; len];
    memory.read(4, &mut bytes);
    let value = Decode!(&bytes, Nat).unwrap();
    COUNTER.with(|cell| *cell.borrow_mut() = value);
}
```
* `rust-region.wasm` is generated by adding the following in the Rust counter code:
```rust
const PROFILING: MemoryId = MemoryId::new(100);
#[ic_cdk::init]
fn init() {
    let memory = MEMORY_MANAGER.with(|m| m.borrow().get(PROFILING));
    memory.grow(32);
}
```
* `classes.wasm` is generated from [dfinity/examples/motoko/classes](https://github.com/dfinity/examples/blob/master/motoko/classes/src/map/Map.mo)
